import bpy
import xml.etree.ElementTree as ET
from xml.dom import minidom
import os


def export_mesh(filepath: str):
    ''' Exports the dae file and its associated textures of the selected objects '''
    bpy.ops.wm.collada_export(
        filepath=filepath,
        check_existing=False,
        filter_collada=True,
        filter_folder=True,
        apply_modifiers=True,
        export_global_forward_selection='X',
        export_global_up_selection='Z',
        filemode=8,
        use_object_instantiation=False,
        limit_precision=True,
        selected=True,
    )


def create_sdf_link(model: ET.Element, object: bpy.types.Object):
    link = ET.SubElement(model, "link", attrib={"name": object.name})
    visual = ET.SubElement(link, "visual", attrib={"name": object.name})

    geometry = ET.SubElement(visual, "geometry")
    mesh = ET.SubElement(geometry, "mesh")
    uri = ET.SubElement(mesh, "uri")
    uri.text = object.name + '.dae'
    submesh = ET.SubElement(mesh, "submesh")
    submesh_name = ET.SubElement(submesh, "name")
    submesh_name.text = object.name

    # grab diffuse/albedo map
    diffuse_map = None
    if object.active_material and object.active_material.node_tree:
        nodes = object.active_material.node_tree.nodes
        principled = next(n for n in nodes if n.type == 'BSDF_PRINCIPLED')
        if principled is not None:
            base_color = principled.inputs['Base Color']  # Or principled.inputs[0]
            # value = base_color.default_value
            if len(base_color.links):
                link_node = base_color.links[0].from_node
                diffuse_map = link_node.image.name

    # setup diffuse/specular color
    material = ET.SubElement(visual, "material")
    diffuse = ET.SubElement(material, "diffuse")
    diffuse.text = "1.0 1.0 1.0 1.0"
    specular = ET.SubElement(material, "specular")
    specular.text = "0.0 0.0 0.0 1.0"
    pbr = ET.SubElement(material, "pbr")
    metal = ET.SubElement(pbr, "metal")
    if diffuse_map:
        albedo_map = ET.SubElement(metal, "albedo_map")
        albedo_map.text = os.path.join('meshes', diffuse_map)

    # sdf collision tags
    collision = ET.SubElement(link, "collision", attrib={"name": "collision"})
    geometry = ET.SubElement(collision, "geometry")
    mesh = ET.SubElement(geometry, "mesh")
    uri = ET.SubElement(mesh, "uri")
    uri.text = object.name

    # surface = ET.SubElement(collision, "surface")
    # contact = ET.SubElement(collision, "contact")
    collide_bitmask = ET.SubElement(collision, "collide_bitmask")
    collide_bitmask.text = "0x01"


def create_config(model_name: str, sdf_filename: str, author_name: str):
    model = ET.Element('model')
    name = ET.SubElement(model, 'name')
    name.text = model_name
    version = ET.SubElement(model, 'version')
    version.text = "1.0"
    sdf_tag = ET.SubElement(model, "sdf", attrib={"sdf": "1.8"})
    sdf_tag.text = sdf_filename

    author = ET.SubElement(model, 'author')
    name = ET.SubElement(author, 'name')
    name.text = author_name

    return model


def export_sdf(path: str, name: str, collection: bpy.types.Collection, author: str = None):
    ''' Exports model.dae of the scene with textures, its corresponding model.sdf file, and a
    default model.config file ####
    '''

    sdf_filename = 'model.sdf'
    model_config_filename = 'model.config'

    if not author:
        author = 'Generated by cropcraft'

    mesh_objects = []

    for object in collection.all_objects.values():
        if object.type == 'MESH':
            bpy.ops.object.select_all(action='DESELECT')
            object.select_set(True)
            export_mesh(os.path.join(path, 'meshes', object.name))
            mesh_objects.append(object)

    # export sdf xml based off the scene
    sdf = ET.Element('sdf', attrib={'version': '1.7'})

    model = ET.SubElement(sdf, "model", attrib={"name": name})
    static = ET.SubElement(sdf, "static")
    static.text = "true"

    # for each object, create a link
    for object in mesh_objects:
        create_sdf_link(model, object)

    # sdf write to file
    xml_string = ET.tostring(sdf, encoding='unicode')
    reparsed = minidom.parseString(xml_string)

    with open(os.path.join(path, sdf_filename), "w") as sdf_file:
        sdf_file.write(reparsed.toprettyxml(indent="  "))

    # create config file
    model = create_config(name, sdf_filename, author)
    xml_string = ET.tostring(model, encoding='unicode')
    reparsed = minidom.parseString(xml_string)

    config_file = open(os.path.join(path, model_config_filename), "w")
    config_file.write(reparsed.toprettyxml(indent="  "))
    config_file.close()
